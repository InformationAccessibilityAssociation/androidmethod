<!DOCTYPE html>

<html lang="zh-CN">
<head>
<title>让自定义的复选框支持无障碍</title>
<link rel="stylesheet" href="../style.css" />
<meta charset="utf-8">
<script type="text/javascript" src="js/jquery.js"></script>
<script type="text/javascript" src="js/jquery.zclip.min.js"></script>
<script type="text/javascript">
$(function(){ 
    $('#copy_input1').zclip({ 
        path: 'js/ZeroClipboard.swf', 
        copy: function(){//复制内容 
            return $('#code1').val(); 
        }, 
        afterCopy: function(){//复制成功 
            $("<span id='msg'/>").insertAfter($('#copy_input')).text('复制成功'); 
        } 
    }); 
}); 
$(function(){ 
    $('#copy_input2').zclip({ 
        path: 'js/ZeroClipboard.swf', 
        copy: function(){//复制内容 
            return $('#code2').val(); 
        }, 
        afterCopy: function(){//复制成功 
            $("<span id='msg'/>").insertAfter($('#copy_input')).text('复制成功'); 
        } 
    }); 
}); 

$(function(){ 
    $('#copy_input3').zclip({ 
        path: 'js/ZeroClipboard.swf', 
        copy: function(){//复制内容 
            return $('#code3').val(); 
        }, 
        afterCopy: function(){//复制成功 
            $("<span id='msg'/>").insertAfter($('#copy_input')).text('复制成功'); 
        } 
    }); 
}); 
$(function(){ 
    $('#copy_input4').zclip({ 
        path: 'js/ZeroClipboard.swf', 
        copy: function(){//复制内容 
            return $('#code4').val(); 
        }, 
        afterCopy: function(){//复制成功 
            $("<span id='msg'/>").insertAfter($('#copy_input')).text('复制成功'); 
        } 
    }); 
}); 

</script>
</head>
<body>
<div class="wrap">
<!-- header begin -->
<div class="header">
    <div ><a href="http://www.siaa.org.cn/"><img src="../logo.png" alt="信息无障碍研究会"  class="logo"/></a></div>
    <!-- nav bar begin -->
    <div class="nav-bar">
        <!-- nav menu begin -->
        <ul>
            <li><a href="../index.html">首页</a></li>
            <li><a href="../index.html">返回</a></li>
        </ul>
        <!-- nav menu end -->
    </div>
    <!-- nav bar end -->
</div>
<!-- header end -->

<!-- body begin -->
<div class="body">
    <h3  >让自定义的复选框支持无障碍____20160601</h3>
    <hr />
    <div>
        <h4  >【问题描述】</h4>
        <hr />
        <p>继承自View的自定义复选框没有经过无障碍处理，无法支持无障碍服务。屏幕阅读器用户无法知道此控件的选中状态、无法知道此控件的类型、及时提示状态改变等。导致屏幕阅读器用户无法使用此控件。</p><!--问题说明-->
    </div>
    <div>
        <h4  >【问题代码】</h4>
        <hr />
        <p>下面是自定义复选框的代码，此复选框选中和取消选中的时候会有动画，选中和未选中的时候控件的展示形式不一样。此自定义控件只有无障碍焦点，不会朗读选中状态，也不会及时朗读状态改变。</p>
		<p>注：此自定义控件的自定义属性xml文件请参看“<a href="#fujian1">附1</a>“；此自定义控件的使用的布局代码请参看“<a href="#fujian2">附2</a>”。</p>
        <textarea rows="380" cols="120" aria-label="问题代码" id="code1">
package com.hanks.library;
import android.animation.ValueAnimator;
import android.annotation.TargetApi;
import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.os.Build;
import android.util.AttributeSet;
import android.view.View;
import android.view.animation.LinearInterpolator;
import android.widget.CheckBox;

import com.hanks.animatecheckbox.R;

public class AnimateCheckBox extends View {

	private static final int DEFAULT_LINE_WIDTH = 4;
	private static final int DEFAULT_LINE_COLOR = Color.WHITE;
	private static final int DEFAULT_CHECKED_COLOR = Color.RED;
	private static final int DEFAULT_UNCHECK_COLOR = Color.GRAY;
	private static final int DEFAULT_ANIM_DURATION = 150;
	private static int DEFAULT_RADIUS = 10;
	private Paint mCirclePaint;
	private Paint mLinePaint;

	private int radius; // 圆的半径
	private int width, height; // 控件宽高
	private int cx, cy; // 圆心xy坐标
	private float[] points = new float[6]; // 对号的3个点的坐标
	private float correctProgress;
	private float downY;
	private boolean isChecked;
	private boolean toggle;
	private boolean isAnim;

	private int animDuration = DEFAULT_ANIM_DURATION;
	private int unCheckColor = DEFAULT_UNCHECK_COLOR;
	private int circleColor = DEFAULT_CHECKED_COLOR;
	private int correctColor = DEFAULT_LINE_COLOR;
	private int correctWidth = DEFAULT_LINE_WIDTH;

	private OnCheckedChangeListener listener;

	public AnimateCheckBox(Context context) {
		this(context, null);
	}

	public AnimateCheckBox(Context context, AttributeSet attrs) {
		this(context, attrs, 0);
	}

	public AnimateCheckBox(Context context, AttributeSet attrs, int defStyleAttr) {
		super(context, attrs, defStyleAttr);

		TypedArray a = context.obtainStyledAttributes(attrs,
				R.styleable.AnimateCheckBox, defStyleAttr, 0);

		circleColor = a.getColor(R.styleable.AnimateCheckBox_checkedColor,
				DEFAULT_CHECKED_COLOR);
		unCheckColor = a.getColor(R.styleable.AnimateCheckBox_unCheckColor,
				DEFAULT_UNCHECK_COLOR);
		correctColor = a.getColor(R.styleable.AnimateCheckBox_lineColor,
				DEFAULT_LINE_COLOR);
		correctWidth = a.getDimensionPixelSize(
				R.styleable.AnimateCheckBox_lineWidth, DEFAULT_LINE_WIDTH);
		animDuration = a.getInteger(R.styleable.AnimateCheckBox_animDuration,
				DEFAULT_ANIM_DURATION);

		a.recycle();

		init(context);

	}

	@TargetApi(Build.VERSION_CODES.LOLLIPOP)
	public AnimateCheckBox(Context context, AttributeSet attrs,
			int defStyleAttr, int defStyleRes) {
		super(context, attrs, defStyleAttr, defStyleRes);
	}

	/**
	 * 根据手机的分辨率从 dp 的单位 转成为 px(像素)
	 */
	public static int dip2px(Context context, float dpValue) {
		final float scale = context.getResources().getDisplayMetrics().density;
		return (int) (dpValue * scale + 0.5f);
	}

	/**
	 * 初始化
	 * 
	 * @param context
	 */
	private void init(Context context) {

		mCirclePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
		mCirclePaint.setStyle(Paint.Style.FILL);
		mCirclePaint.setColor(circleColor);

		mLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
		mLinePaint.setStyle(Paint.Style.FILL);
		mLinePaint.setColor(correctColor);
		mLinePaint.setStrokeWidth(correctWidth);

		setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isChecked) {
					hideCorrect();
				} else {
					showCheck();
				}
			}
		});
	}

	/**
	 * 返回当前选中状态
	 * 
	 * @return
	 */
	public boolean isChecked() {
		return isChecked;
	}

	/**
	 * 设置当前选中状态
	 * 
	 * @param checked
	 */
	public void setChecked(boolean checked) {
		if (isChecked && !checked) {
			hideCorrect();
		} else if (!isChecked && checked) {
			showCheck();
		}
	}

	public void setUncheckStatus() {
		isChecked = false;
		radius = DEFAULT_RADIUS;
		correctProgress = 0;
		invalidate();
	}

	/**
	 * 确定尺寸坐标
	 * 
	 * @param w
	 * @param h
	 * @param oldw
	 * @param oldh
	 */
	@Override
	protected void onSizeChanged(int w, int h, int oldw, int oldh) {
		super.onSizeChanged(w, h, oldw, oldh);
		height = width = Math.min(w - getPaddingLeft() - getPaddingRight(), h
				- getPaddingBottom() - getPaddingTop());
		cx = w / 2;
		cy = h / 2;

		float r = height / 2f;
		points[0] = r / 2f + getPaddingLeft();
		points[1] = r + getPaddingTop();

		points[2] = r * 5f / 6f + getPaddingLeft();
		points[3] = r + r / 3f + getPaddingTop();

		points[4] = r * 1.5f + getPaddingLeft();
		points[5] = r - r / 3f + getPaddingTop();
		DEFAULT_RADIUS = radius = (int) (height * 0.125f);
	}

	@Override
	protected void onDraw(Canvas canvas) {

		float f = (radius - height * 0.125f) / (height * 0.5f); // 当前进度
		mCirclePaint.setColor(evaluate(f, unCheckColor, circleColor));
		canvas.drawCircle(cx, cy, radius, mCirclePaint); // 画圆

		// 画对号
		if (correctProgress > 0) {
			if (correctProgress < 1 / 3f) {
				float x = points[0] + (points[2] - points[0]) * correctProgress;
				float y = points[1] + (points[3] - points[1]) * correctProgress;
				canvas.drawLine(points[0], points[1], x, y, mLinePaint);
			} else {
				float x = points[2] + (points[4] - points[2]) * correctProgress;
				float y = points[3] + (points[5] - points[3]) * correctProgress;
				canvas.drawLine(points[0], points[1], points[2], points[3],
						mLinePaint);
				canvas.drawLine(points[2], points[3], x, y, mLinePaint);
			}
		}
	}

	/**
	 * 设置圆的颜色
	 * 
	 * @param color
	 */
	public void setCircleColor(int color) {
		circleColor = color;
	}

	/**
	 * 设置对号的颜色
	 * 
	 * @param color
	 */
	public void setLineColor(int color) {
		mLinePaint.setColor(color);
	}

	/**
	 * 设置未选中时的颜色
	 * 
	 * @param color
	 */
	public void setUnCheckColor(int color) {
		unCheckColor = color;
	}

	private int evaluate(float fraction, int startValue, int endValue) {
		if (fraction <= 0) {
			return startValue;
		}
		if (fraction >= 1) {
			return endValue;
		}
		int startInt = startValue;
		int startA = (startInt >> 24) & 0xff;
		int startR = (startInt >> 16) & 0xff;
		int startG = (startInt >> 8) & 0xff;
		int startB = startInt & 0xff;

		int endInt = endValue;
		int endA = (endInt >> 24) & 0xff;
		int endR = (endInt >> 16) & 0xff;
		int endG = (endInt >> 8) & 0xff;
		int endB = endInt & 0xff;

		return ((startA + (int) (fraction * (endA - startA))) << 24)
				| ((startR + (int) (fraction * (endR - startR))) << 16)
				| ((startG + (int) (fraction * (endG - startG))) << 8)
				| ((startB + (int) (fraction * (endB - startB))));
	}

	/**
	 * 处理触摸事件触发动画
	 */
	/*
	 * private class OnChangeStatusListener implements OnTouchListener {
	 * 
	 * @Override public boolean onTouch(View v, MotionEvent event) {
	 * Log.i("Touch","Touch"); switch (event.getAction()) { case
	 * MotionEvent.ACTION_DOWN: downY = event.getRawY(); break; case
	 * MotionEvent.ACTION_MOVE: float dy = event.getRawY() - downY; if
	 * (Math.abs(dy) >= 0) { //滑过一半触发 toggle = true; } else { toggle = false; }
	 * break; case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_UP: if
	 * (toggle) { if (isChecked) { hideCorrect(); } else { showCheck(); } }
	 * break; } return true; } }
	 */
	private void showUnChecked() {
		if (isAnim) {
			return;
		}

		isAnim = true;
		ValueAnimator va = ValueAnimator.ofFloat(0, 1)
				.setDuration(animDuration);
		va.setInterpolator(new LinearInterpolator());
		va.start();
		va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
			@Override
			public void onAnimationUpdate(ValueAnimator animation) {
				float value = Float.parseFloat(animation.getAnimatedValue()
						.toString()); // 0f ~ 1f
				radius = (int) ((1 - value) * height * 0.375f + height * 0.125f);
				if (value >= 1) {
					isChecked = false;
					isAnim = false;
					if (listener != null) {
						listener.onCheckedChanged(AnimateCheckBox.this, false);
					}
				}
				invalidate();
			}
		});
	}

	private void showCheck() {
		if (isAnim) {
			return;
		}
		isAnim = true;
		ValueAnimator va = ValueAnimator.ofFloat(0, 1)
				.setDuration(animDuration);
		va.setInterpolator(new LinearInterpolator());
		va.start();
		va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
			@Override
			public void onAnimationUpdate(ValueAnimator animation) {
				float value = Float.parseFloat(animation.getAnimatedValue()
						.toString()); // 0f ~ 1f
				radius = (int) (value * height * 0.37f + height * 0.125f);
				if (value >= 1) {
					isChecked = true;
					isAnim = false;
					if (listener != null) {
						listener.onCheckedChanged(AnimateCheckBox.this, true);
					}
					showCorrect();
				}
				invalidate();
			}
		});
	}

	private void showCorrect() {
		if (isAnim) {
			return;
		}
		isAnim = true;
		ValueAnimator va = ValueAnimator.ofFloat(0, 1)
				.setDuration(animDuration);
		va.setInterpolator(new LinearInterpolator());
		va.start();
		va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
			@Override
			public void onAnimationUpdate(ValueAnimator animation) {
				float value = Float.parseFloat(animation.getAnimatedValue()
						.toString()); // 0f ~ 1f
				correctProgress = value;
				invalidate();
				if (value >= 1) {
					isAnim = false;
				}
			}
		});
	}

	private void hideCorrect() {
		if (isAnim) {
			return;
		}
		isAnim = true;
		ValueAnimator va = ValueAnimator.ofFloat(0, 1)
				.setDuration(animDuration);
		va.setInterpolator(new LinearInterpolator());
		va.start();
		va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
			@Override
			public void onAnimationUpdate(ValueAnimator animation) {
				float value = Float.parseFloat(animation.getAnimatedValue()
						.toString()); // 0f ~ 1f
				correctProgress = 1 - value;
				invalidate();
				if (value >= 1) {
					isAnim = false;
					showUnChecked();
				}
			}
		});
	}

	public void setOnCheckedChangeListener(OnCheckedChangeListener listener) {
		this.listener = listener;
	}


	public interface OnCheckedChangeListener {
		void onCheckedChanged(View buttonView, boolean isChecked);
	}
}
        </textarea><br/>
        <a href="#" id="copy_input1" class="copy">复制内容</a> 
    </div>
    <div>
        <h4  >【问题解决方案描述】</h4>
        <hr />
        <p>自定义控件要支持无障碍需要重写与无障碍有关的方法。<code>onInitializeAccessibilityEvent()</code>方法是初始化无障碍事件的方法；<code>onInitializeAccessibilityNodeInfo()</code>此方法是初始化无障碍节点的方法；<code>onPopulateAccessibilityEvent()</code>此方法是填充无障碍文本的方法，在此方法中最好只设置无障碍文本不要设置除无障碍文本之外的其他属性，在此方法中设置除无障碍文本之外的属性会被其他方法覆盖，要设置其他的无障碍属性请在<code>onInitializeAccessibilityEvent()</code>方法中设置；这3个方法是主要的无障碍方法、还有一些其他的方法可以根据实际情况重写这些方法。</p>
		<p>本解决方案中的自定义复选框，因为没有文本，所以没有重写<code>onPopulateAccessibilityEvent()</code>方法。重写了<code>onInitializeAccessibilityEvent()</code>和<code>onInitializeAccessibilityNodeInfo()</code>方法，此外还重写了<code>sendAccessibilityEvent()</code>，在此方法中不处理<code>AccessibilityEvent_TYPE_VIEW_CLICKED</code>(点击事件)，因为无障碍事件设置了选中状态之后收到<code>AccessibilityEvent.TYPE_VIEW_CLICKED</code>事件会及时朗读选中状态的改变，但是及时朗读的选中状态不正确，在音点击之后本自定义控件不是马上改变选中状态而是有一段时间的动画，所以状态改变有一定的延迟，这导致<code>AccessibilityEvent.TYPE_VIEW_SELECTED</code>也不能正确的朗读出及时的选中状态。在本解决方案中在点击事件中利用<code>View.postDelayed()</code>方法延迟发送无障碍事件来做到及时朗读状态改变的效果。</p>
    </div>
    <div>
        <h4  >【解决方案】</h4>
        <hr />
		<p>下面的代码重写了<code>onInitializeAccessibilityEvent()</code>、<code>onInitializeAccessibilityNodeInfo()</code>、<code>sendAccessibilityEvent()</code>。在点击事件（<code>onClick</code>）中利用<code>View.postDelayed()</code>方法延迟发送无障碍事件。达到的效果是：获得焦点的时候会朗读选中状态+控件类型，如”已选中 复选框“，点击之后会及时朗读新的选中状态，朗读的形式和获得焦点的时候一致。</p>
        <textarea rows="14" cols="120" aria-label="解决方案代码" id="code2">
package com.hanks.library;

import android.animation.ValueAnimator;
import android.annotation.TargetApi;
import android.content.Context;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.os.Build;
import android.util.AttributeSet;
import android.view.View;
import android.view.accessibility.AccessibilityEvent;
import android.view.accessibility.AccessibilityNodeInfo;
import android.view.animation.LinearInterpolator;
import android.widget.CheckBox;

import com.hanks.animatecheckbox.R;

public class AnimateCheckBox extends View {

	private static final int DEFAULT_LINE_WIDTH = 4;
	private static final int DEFAULT_LINE_COLOR = Color.WHITE;
	private static final int DEFAULT_CHECKED_COLOR = Color.RED;
	private static final int DEFAULT_UNCHECK_COLOR = Color.GRAY;
	private static final int DEFAULT_ANIM_DURATION = 150;
	private static int DEFAULT_RADIUS = 10;
	private Paint mCirclePaint;
	private Paint mLinePaint;

	private int radius; // 圆的半径
	private int width, height; // 控件宽高
	private int cx, cy; // 圆心xy坐标
	private float[] points = new float[6]; // 对号的3个点的坐标
	private float correctProgress;
	private float downY;
	private boolean isChecked;
	private boolean toggle;
	private boolean isAnim;

	private int animDuration = DEFAULT_ANIM_DURATION;
	private int unCheckColor = DEFAULT_UNCHECK_COLOR;
	private int circleColor = DEFAULT_CHECKED_COLOR;
	private int correctColor = DEFAULT_LINE_COLOR;
	private int correctWidth = DEFAULT_LINE_WIDTH;

	private OnCheckedChangeListener listener;

	public AnimateCheckBox(Context context) {
		this(context, null);
	}

	public AnimateCheckBox(Context context, AttributeSet attrs) {
		this(context, attrs, 0);
	}

	public AnimateCheckBox(Context context, AttributeSet attrs, int defStyleAttr) {
		super(context, attrs, defStyleAttr);

		TypedArray a = context.obtainStyledAttributes(attrs,
				R.styleable.AnimateCheckBox, defStyleAttr, 0);

		circleColor = a.getColor(R.styleable.AnimateCheckBox_checkedColor,
				DEFAULT_CHECKED_COLOR);
		unCheckColor = a.getColor(R.styleable.AnimateCheckBox_unCheckColor,
				DEFAULT_UNCHECK_COLOR);
		correctColor = a.getColor(R.styleable.AnimateCheckBox_lineColor,
				DEFAULT_LINE_COLOR);
		correctWidth = a.getDimensionPixelSize(
				R.styleable.AnimateCheckBox_lineWidth, DEFAULT_LINE_WIDTH);
		animDuration = a.getInteger(R.styleable.AnimateCheckBox_animDuration,
				DEFAULT_ANIM_DURATION);

		a.recycle();

		init(context);

	}

	@TargetApi(Build.VERSION_CODES.LOLLIPOP)
	public AnimateCheckBox(Context context, AttributeSet attrs,
			int defStyleAttr, int defStyleRes) {
		super(context, attrs, defStyleAttr, defStyleRes);
	}

	/**
	 * 根据手机的分辨率从 dp 的单位 转成为 px(像素)
	 */
	public static int dip2px(Context context, float dpValue) {
		final float scale = context.getResources().getDisplayMetrics().density;
		return (int) (dpValue * scale + 0.5f);
	}

	/**
	 * 初始化
	 * 
	 * @param context
	 */
	private void init(Context context) {

		mCirclePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
		mCirclePaint.setStyle(Paint.Style.FILL);
		mCirclePaint.setColor(circleColor);

		mLinePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
		mLinePaint.setStyle(Paint.Style.FILL);
		mLinePaint.setColor(correctColor);
		mLinePaint.setStrokeWidth(correctWidth);

		setOnClickListener(new OnClickListener() {
			@Override
			public void onClick(View v) {
				if (isChecked) {
					hideCorrect();
				} else {
					showCheck();
				}

/*
因为无障碍属性里面设置了选中状态之后发送AccessibilityEvent.TYPE_VIEW_CLICKED事件（调用onClick()方法会发送此事件）朗读的及时状态不对
*所以此处音发送AccessibilityEvent.TYPE_VIEW_SELECTED事件
*又因为本自定义控件点击之后不能马上改变选中状态的变量isChecked，点击之后会有一段时间的动画
* 所以下面利用View.postDelayed()方法延迟发送无障碍事件
*注：状态改变的常量isChecked没有延迟的时候在此处调用sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED)就可以达到正确的朗读状态改变的效果
*/
				AnimateCheckBox.this.postDelayed(sendRun, 500);
			}
		});
	}

	/**
	 * 返回当前选中状态
	 * 
	 * @return
	 */
	public boolean isChecked() {
		return isChecked;
	}

	/**
	 * 设置当前选中状态
	 * 
	 * @param checked
	 */
	public void setChecked(boolean checked) {
		if (isChecked && !checked) {
			hideCorrect();
		} else if (!isChecked && checked) {
			showCheck();
		}
	}

	public void setUncheckStatus() {
		isChecked = false;
		radius = DEFAULT_RADIUS;
		correctProgress = 0;
		invalidate();
	}

	/**
	 * 确定尺寸坐标
	 * 
	 * @param w
	 * @param h
	 * @param oldw
	 * @param oldh
	 */
	@Override
	protected void onSizeChanged(int w, int h, int oldw, int oldh) {
		super.onSizeChanged(w, h, oldw, oldh);
		height = width = Math.min(w - getPaddingLeft() - getPaddingRight(), h
				- getPaddingBottom() - getPaddingTop());
		cx = w / 2;
		cy = h / 2;

		float r = height / 2f;
		points[0] = r / 2f + getPaddingLeft();
		points[1] = r + getPaddingTop();

		points[2] = r * 5f / 6f + getPaddingLeft();
		points[3] = r + r / 3f + getPaddingTop();

		points[4] = r * 1.5f + getPaddingLeft();
		points[5] = r - r / 3f + getPaddingTop();
		DEFAULT_RADIUS = radius = (int) (height * 0.125f);
	}

	@Override
	protected void onDraw(Canvas canvas) {

		float f = (radius - height * 0.125f) / (height * 0.5f); // 当前进度
		mCirclePaint.setColor(evaluate(f, unCheckColor, circleColor));
		canvas.drawCircle(cx, cy, radius, mCirclePaint); // 画圆

		// 画对号
		if (correctProgress > 0) {
			if (correctProgress < 1 / 3f) {
				float x = points[0] + (points[2] - points[0]) * correctProgress;
				float y = points[1] + (points[3] - points[1]) * correctProgress;
				canvas.drawLine(points[0], points[1], x, y, mLinePaint);
			} else {
				float x = points[2] + (points[4] - points[2]) * correctProgress;
				float y = points[3] + (points[5] - points[3]) * correctProgress;
				canvas.drawLine(points[0], points[1], points[2], points[3],
						mLinePaint);
				canvas.drawLine(points[2], points[3], x, y, mLinePaint);
			}
		}
	}

	/**
	 * 设置圆的颜色
	 * 
	 * @param color
	 */
	public void setCircleColor(int color) {
		circleColor = color;
	}

	/**
	 * 设置对号的颜色
	 * 
	 * @param color
	 */
	public void setLineColor(int color) {
		mLinePaint.setColor(color);
	}

	/**
	 * 设置未选中时的颜色
	 * 
	 * @param color
	 */
	public void setUnCheckColor(int color) {
		unCheckColor = color;
	}

	private int evaluate(float fraction, int startValue, int endValue) {
		if (fraction <= 0) {
			return startValue;
		}
		if (fraction >= 1) {
			return endValue;
		}
		int startInt = startValue;
		int startA = (startInt >> 24) & 0xff;
		int startR = (startInt >> 16) & 0xff;
		int startG = (startInt >> 8) & 0xff;
		int startB = startInt & 0xff;

		int endInt = endValue;
		int endA = (endInt >> 24) & 0xff;
		int endR = (endInt >> 16) & 0xff;
		int endG = (endInt >> 8) & 0xff;
		int endB = endInt & 0xff;

		return ((startA + (int) (fraction * (endA - startA))) << 24)
				| ((startR + (int) (fraction * (endR - startR))) << 16)
				| ((startG + (int) (fraction * (endG - startG))) << 8)
				| ((startB + (int) (fraction * (endB - startB))));
	}

	/**
	 * 处理触摸事件触发动画
	 */
	/*
	 * private class OnChangeStatusListener implements OnTouchListener {
	 * 
	 * @Override public boolean onTouch(View v, MotionEvent event) {
	 * Log.i("Touch","Touch"); switch (event.getAction()) { case
	 * MotionEvent.ACTION_DOWN: downY = event.getRawY(); break; case
	 * MotionEvent.ACTION_MOVE: float dy = event.getRawY() - downY; if
	 * (Math.abs(dy) >= 0) { //滑过一半触发 toggle = true; } else { toggle = false; }
	 * break; case MotionEvent.ACTION_CANCEL: case MotionEvent.ACTION_UP: if
	 * (toggle) { if (isChecked) { hideCorrect(); } else { showCheck(); } }
	 * break; } return true; } }
	 */
	private void showUnChecked() {
		if (isAnim) {
			return;
		}

		isAnim = true;
		ValueAnimator va = ValueAnimator.ofFloat(0, 1)
				.setDuration(animDuration);
		va.setInterpolator(new LinearInterpolator());
		va.start();
		va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
			@Override
			public void onAnimationUpdate(ValueAnimator animation) {
				float value = Float.parseFloat(animation.getAnimatedValue()
						.toString()); // 0f ~ 1f
				radius = (int) ((1 - value) * height * 0.375f + height * 0.125f);
				if (value >= 1) {
					isChecked = false;
					isAnim = false;
					if (listener != null) {
						listener.onCheckedChanged(AnimateCheckBox.this, false);
					}
				}
				invalidate();
			}
		});
	}

	private void showCheck() {
		if (isAnim) {
			return;
		}
		isAnim = true;
		ValueAnimator va = ValueAnimator.ofFloat(0, 1)
				.setDuration(animDuration);
		va.setInterpolator(new LinearInterpolator());
		va.start();
		va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
			@Override
			public void onAnimationUpdate(ValueAnimator animation) {
				float value = Float.parseFloat(animation.getAnimatedValue()
						.toString()); // 0f ~ 1f
				radius = (int) (value * height * 0.37f + height * 0.125f);
				if (value >= 1) {
					isChecked = true;
					isAnim = false;
					if (listener != null) {
						listener.onCheckedChanged(AnimateCheckBox.this, true);
					}
					showCorrect();
				}
				invalidate();
			}
		});
	}

	private void showCorrect() {
		if (isAnim) {
			return;
		}
		isAnim = true;
		ValueAnimator va = ValueAnimator.ofFloat(0, 1)
				.setDuration(animDuration);
		va.setInterpolator(new LinearInterpolator());
		va.start();
		va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
			@Override
			public void onAnimationUpdate(ValueAnimator animation) {
				float value = Float.parseFloat(animation.getAnimatedValue()
						.toString()); // 0f ~ 1f
				correctProgress = value;
				invalidate();
				if (value >= 1) {
					isAnim = false;
				}
			}
		});
	}

	private void hideCorrect() {
		if (isAnim) {
			return;
		}
		isAnim = true;
		ValueAnimator va = ValueAnimator.ofFloat(0, 1)
				.setDuration(animDuration);
		va.setInterpolator(new LinearInterpolator());
		va.start();
		va.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
			@Override
			public void onAnimationUpdate(ValueAnimator animation) {
				float value = Float.parseFloat(animation.getAnimatedValue()
						.toString()); // 0f ~ 1f
				correctProgress = 1 - value;
				invalidate();
				if (value >= 1) {
					isAnim = false;
					showUnChecked();
				}
			}
		});
	}

	public void setOnCheckedChangeListener(OnCheckedChangeListener listener) {
		this.listener = listener;
	}
	//重写sendAccessibilityEvent()方法，在此方法中不处理AccessibilityEvent.TYPE_VIEW_CLICKED事件
	//因为无障碍事件设置了选中状态之后此事件及时朗读的选中状态不正确
	@Override
	public void sendAccessibilityEvent(int type) {
		if (type == AccessibilityEvent.TYPE_VIEW_CLICKED) {
			return;
		}

		super.sendAccessibilityEvent(type);
	}

	//重写onInitializeAccessibilityEvent()方法
	//在此方法中设置无障碍事件的属性
	@Override
	public void onInitializeAccessibilityEvent(AccessibilityEvent event) {
		super.onInitializeAccessibilityEvent(event);
		//设置无障碍事件的类名，设置为CheckBox无障碍服务会把控件类型朗读为CheckBox
		event.setClassName(CheckBox.class.getName());
		//设置选中状态
		event.setChecked(isChecked);
	}

	//重写onInitializeAccessibilityNodeInfo()方法
	//在此方法中设置无障碍节点的属性
	@Override
	public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {
		super.onInitializeAccessibilityNodeInfo(info);
		//设置类名为CheckBox，无障碍服务会把控件类型朗读为CheckBox
		info.setClassName(CheckBox.class.getName());
		//设置可选中
		info.setCheckable(true);
		//设置选中状态
		info.setChecked(isChecked);
	}

	//发送无障碍事件的县城
	private Thread sendRun = new Thread() {
		@Override
		public void run() {
		//发送此事件之后朗读的结果和获得无障碍焦点朗读的结果一致
			AnimateCheckBox.this.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);
		}
	};
	public interface OnCheckedChangeListener {
		void onCheckedChanged(View buttonView, boolean isChecked);
	}
}
        </textarea><br/>
        <a href="#" id="copy_input2" class="copy">复制内容</a> 
    </div>
    <div>
        <h4  >【前后效果图对比】</h4>
        <hr />
        <table>
            <tr>
                <td><img src="../images/41-1.png" class="litu" alt="" aria-labelledby="img1_label"/></td><td><img src="../images/41-2.png" class="litu" alt="" aria-labelledby="img2_label"/></td>
            </tr>
            <tr>
                <td id="img1_label">优化前，复选框有焦点，聚焦和点击均无提示；</td><td id="img2_label">优化后，复选框聚焦提示当前选中状态，点击后，提示点击后的选中状态；</td>
            </tr>
        </table>
    </div>
    <div>
        <h4  >【扩展】</h4>
        <hr />
        <p>让自定义的复选框支持无障碍<a href="../apk/41_apk.apk">apk</a></p>
    </div>
    <div>
        <h4  >【更多】</h4>
        <hr />
        <p><a name="fujian1"></a>【附1】 自定义控件的属性xml文件代码</p>
		<textarea rows="12" cols="120" aria-label="附件1代码" id="code3">
Attrs.xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="AnimateCheckBox">
        <attr name="unCheckColor" format="color"/>
        <attr name="checkedColor" format="color"/>
        <attr name="lineColor" format="color"/>
        <attr name="lineWidth" format="dimension"/>
        <attr name="animDuration" format="integer"/>
    </declare-styleable>
</resources>
        </textarea><br/>
        <a href="#" id="copy_input3" class="copy">复制内容</a>
		<p><a name="fujian2">【附2】 此自定义控件的使用布局代码</p>
		<textarea rows="21" cols="120" aria-label="附件2代码" id="code4">
activity_main.xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <com.hanks.library.AnimateCheckBox
        android:layout_width="50dp"
        android:layout_height="50dp"
        android:padding="15dp"
        app:animDuration="200"
        app:checkedColor="#00f"
        app:lineColor="#fff"
        app:lineWidth="1.2dp"
        app:unCheckColor="#ff0"
        android:focusable="true"/>
</RelativeLayout>
        </textarea><br/>
        <a href="#" id="copy_input4" class="copy">复制内容</a>
    </div>
</div>
<!-- body end -->
<br/>
<hr/>
<!-- footer begin -->
<div class="footer">
<p class="copyright">深圳市信息无障碍研究会 版权所有.Copyright © 2016 ARA. All 
Rights Reserved. <a href="http://www.miibeian.gov.cn/" target="_blank">粤ICP备10065437号</a> </p>
<p class="copyright">地址：深圳市福田区雨田路1号富莲大厦一栋一层</p>
</div>
<!-- footer end -->
</div>
<!-- wrap end -->
</body>
</html>
